# qtlApp Cursor Rules

## Project Overview

This is an R package for QTL (Quantitative Trait Loci) analysis and visualization using Shiny. The project is organized as a modular package with multiple small Shiny modules for scalable QTL analysis with support for interactive sex/diet difference plots.

## R Language Standards

### Code Style

- Use 2-space indentation consistently throughout all R files
- Use `|>` (native pipe) instead of `%>%` (magrittr pipe) for new code
- Be explicit about package namespacing: use `package::function()` format
- Use snake_case for function names and variables
- Use descriptive variable names that clearly indicate their purpose

### Function Documentation

- All exported functions must have roxygen2 documentation with `@export`
- Include `@param` for all parameters with clear descriptions
- Include `@return` to describe what the function returns
- Add `@importFrom` for specific package functions used
- Example format:

```r
#' Function description
#' @param param_name Description of parameter
#' @return Description of return value
#' @importFrom package function
#' @export
```

### Error Handling

- Use `shiny::req()` for required inputs in Shiny contexts
- Implement comprehensive error checking with informative warning messages
- Check for NULL values, empty data frames, and missing columns before processing
- Return appropriate default values (e.g., `character(0)`, `NULL`) when data is invalid
- Use `warning()` for non-fatal issues with descriptive messages

### Data Validation

- Always validate data frame structure before processing
- Check for required columns using `%in% colnames()`
- Validate data types and handle type conversions safely
- Filter out NA values and empty strings where appropriate
- Use `is.null()`, `is.data.frame()`, `nrow() == 0` checks

## Shiny Application Structure

### Modular Design

- Break functionality into small, focused Shiny modules (~50-100 lines each)
- Each module should handle a specific task (scanning, peaks, traits, interactive analysis, etc.)
- Use consistent naming: `*Module.R` for module files
- Modules should be interconnectable like "legos"

### File Organization

- Main app logic in `app.R`
- Helper functions in `R/helpers.R`
- Data handling functions in `R/data_handling.R`
- Each major feature gets its own module file in `R/`
- UI styling in `R/ui_styles.R`
- Plot functions separated by type (ggplot, plotly, etc.)

### Modular Architecture Patterns

#### Core Modules

- `scanPlotModule.R` - LOD scan visualization with interactive/difference plots
- `alleleEffectsModule.R` - Strain effects visualization and peak selection
- `interactiveAnalysisModule.R` - Sex/diet interaction controls
- `datasetSelectionModule.R` - Dataset category and specific dataset selection

#### Module Communication

- Use reactive values and functions for inter-module communication
- Pass reactive parameters explicitly to maintain clear dependencies
- Return reactive values from modules for external access
- Use debouncing (`shiny::debounce()`) on expensive reactive operations

#### Module Patterns

```r
#' Module Server Pattern
moduleServer <- function(id, param1_reactive, param2_reactive, ...) {
  shiny::moduleServer(id, function(input, output, session) {
    ns <- session$ns

    # Local reactive values
    local_rv <- shiny::reactiveVal(NULL)

    # Debounced reactives for performance
    expensive_computation <- shiny::reactive({
      # computation logic
    }) %>% shiny::debounce(200)

    # Return reactive interface
    return(list(
      output_reactive = local_rv,
      computed_data = expensive_computation
    ))
  })
}
```

### Shiny Best Practices

- Use `bslib` for modern Bootstrap styling
- Implement loading indicators with `shinycssloaders`
- Use `shinyjs` for enhanced interactivity
- Set appropriate file upload limits: `options(shiny.maxRequestSize = 20000*1024^2)`
- Use reactive expressions efficiently to avoid unnecessary computations

### Performance Optimization

#### Reactive Debouncing

- Use `shiny::debounce()` on expensive reactive operations
- Debounce ranges: 100-150ms for data processing, 200-300ms for plot creation, 200-250ms for difference plots
- Example: `reactive_function %>% shiny::debounce(200)`

#### Reactive Dependency Management

- Avoid circular reactive dependencies
- Use `shiny::isolate()` when needed to break reactive chains
- Use `shiny::req()` to prevent premature reactive execution
- Clear reactive flags and use timed resets for UI state management

#### Preventing Double Firing in UI Reactive Chains

**Problem**: UI components that depend on reactive values which in turn depend on UI inputs can create circular reactive dependencies, causing UI to fire multiple times.

**Solution Pattern**: Separate base reactives from mapped/derived reactives to break circular dependencies.

```r
# WRONG: Circular dependency causes double firing
main_reactive <- shiny::reactive({
  base_value <- input$base_selector
  ui_dependent_value <- input$ui_selector  # UI depends on this reactive!
  # Process both values together
  process_values(base_value, ui_dependent_value)
})

# UI that depends on main_reactive creates circular dependency
output$ui_section <- shiny::renderUI({
  result <- main_reactive()  # This can trigger when input$ui_selector changes
  # Render UI that includes input$ui_selector
})

# CORRECT: Separate base and mapped reactives
base_reactive <- shiny::reactive({
  base_value <- input$base_selector
  # NO dependency on UI-dependent inputs
  return(base_value)
})

mapped_reactive <- shiny::reactive({
  base_value <- base_reactive()
  ui_value <- input$ui_selector
  # Only this reactive depends on UI input
  process_values(base_value, ui_value)
})

# UI depends only on base reactive (no circular dependency)
output$ui_section <- shiny::renderUI({
  base_value <- base_reactive()  # Independent of input$ui_selector
  # Render UI safely
})

# Data processing uses mapped reactive
process_data <- function() {
  mapped_value <- mapped_reactive()  # Gets the mapped result
  # Use mapped value for actual processing
}
```

**Key Principles**:

- Base reactives should be independent of UI elements they influence
- Create separate mapping reactives for conditional logic
- UI renderUI functions should depend only on stable base reactives
- Use mapped reactives for data processing that needs conditional values

**Alternative Correct Pattern: `reactiveVal` with `observeEvent`**

This pattern is especially useful when an input's value needs to be stored as a state that survives the re-rendering of the input control itself. It explicitly decouples state management from the UI.

```r
# 1. In the server, create a reactiveVal to hold the state.
# This acts as a stable, manually controlled "source of truth".
stored_interaction_type <- shiny::reactiveVal("none")

# 2. Use observeEvent to update the reactiveVal only when the input changes.
# ignoreNULL and ignoreInit prevent unwanted updates during startup or re-rendering.
shiny::observeEvent(input$interaction_type_selector, {
  stored_interaction_type(input$interaction_type_selector)
}, ignoreNULL = TRUE, ignoreInit = TRUE)

# 3. Downstream reactives safely use the stored value.
# This reactive does NOT depend on `input$interaction_type_selector` directly.
# It only depends on the stable `stored_interaction_type` reactiveVal.
mapped_dataset <- shiny::reactive({
  base_dataset <- base_dataset_reactive()
  interaction <- stored_interaction_type() # Uses the stable value
  # ... logic to map dataset based on interaction ...
})

# The UI rendering can also safely use the reactiveVal to preserve state.
output$interaction_ui <- shiny::renderUI({
  # This UI creates `input$interaction_type_selector`.
  # When it re-renders, the `selected` value is preserved via the reactiveVal,
  # and the `observeEvent` ensures logic only runs on direct user changes.
  shiny::selectInput(
    "interaction_type_selector",
    label = "Interaction",
    choices = c("None" = "none", "Sex" = "sex"),
    selected = stored_interaction_type() # Persist selection across re-renders
  )
})
```

#### Trait Preservation and Auto-Search

- Preserve trait selection when switching between compatible datasets (e.g., additive ↔ interactive)
- Use `dataset_just_changed` flags to prevent auto-search during dataset transitions
- Implement intelligent auto-search with user control (search button + auto-trigger)
- Use server-side selectize for large trait lists with `server = TRUE`

## Interactive Analysis and Difference Plots

### Sex/Diet Interaction Support

- Support interactive analysis for specific datasets (HC_HF Liver Genes)
- Automatically map interaction types to correct dataset names:
  - "none" → base dataset (additive)
  - "sex" → "HC_HF Liver Genes, interactive (Sex)"
  - "diet" → "HC_HF Liver Genes, interactive (Diet)"

### Difference Plot Implementation Using qtlxcovar Files

#### Overview Plot Difference Analysis (Manhattan/Cis-Trans)

- **Data Source**: Use pre-computed qtlxcovar files in `/data/dev/miniViewer_3.0/` for interactive analysis
- **Key Column**: `lod_diff` contains the actual difference values (interactive - additive)
- **File Mapping**:
  - Liver Genes: `DO1200_liver_genes_all_mice_qtlx[sex|diet]_peaks.csv`
  - Clinical Traits: `DO1200_clinical_traits_all_mice_qtlx[sex|diet]_peaks.csv`
  - Liver Lipids: `DO1200_liver_lipids_all_mice_qtlx[diet]_peaks.csv`
  - Plasma Metabolites: `DO1200_plasma_metabolites_all_mice_qtlx[sex]_peaks.csv`

#### LOD Column Selection Logic

```r
# Detect qtlxcovar data
is_qtlxcovar_data <- "lod_diff" %in% colnames(df)
use_lod_diff <- is_qtlxcovar_data && interaction_type != "none"

# Use appropriate column for filtering and plotting
lod_column <- if (use_lod_diff) "lod_diff" else "qtl_lod"

# For difference data, use absolute value for threshold filtering
if (use_lod_diff) {
  df_filtered <- dplyr::filter(df, abs(lod_diff) >= lod_threshold)
  # Store original signed values for hover text
  df_filtered$lod_diff_original <- df_filtered$lod_diff
  # Use absolute value for plotting
  df_filtered$qtl_lod <- abs(df_filtered$lod_diff)
}
```

#### Plot Title Logic

- **Manhattan Plots**: Show "Manhattan Plot - [Sex/Diet] Interaction Difference" for qtlxcovar data
- **Cis-Trans Plots**: Show "Cis/Trans QTL Plot - [Sex/Diet] Interaction Differences" for qtlxcovar data
- **Hover Text**: For difference data, show both signed and absolute LOD difference values

### Difference Plot Architecture for LOD Scans

```r
# Store additive data when interaction type is "none"
additive_scan_data_rv <- shiny::reactiveVal(NULL)

# Create difference plot
difference_plot_gg <- shiny::reactive({
  interactive_data <- scan_table_chr()
  additive_data <- additive_scan_data_rv()

  # Simple subtraction with NA handling
  lod_difference <- interactive_data$LOD - additive_data$LOD
  lod_difference[is.na(lod_difference)] <- 0

  # Create plot data
  diff_plot_data <- interactive_data
  diff_plot_data$LOD <- lod_difference

  ggplot_qtl_scan(diff_plot_data, -Inf, selected_chr)
}) %>% shiny::debounce(250)
```

### UI Stacking for Interactive Analysis

- **Single Plot**: Standard LOD scan for additive datasets
- **Stacked Plots**: Interactive LOD (top) + Difference LOD (bottom) for interactive datasets
- **Plot Titles**: "Interactive LOD Scan" and "LOD Difference (Interactive - Additive)"
- **Color Coding**: Blue spinners for main plots, red spinners for difference plots

### LOD Scan Overlays (Transposition Toggles)

- **Objective**: Allow direct comparison of additive and interactive LOD scans on a single plot for compatible datasets.
- **UI**: When viewing an additive scan for an `HC_HF` dataset that has interactive counterparts, "Overlay Diet Interactive" and "Overlay Sex Interactive" toggles will appear next to the chromosome selector.
- **Functionality**:
  - Activating a toggle fetches the corresponding interactive scan data for the current trait.
  - The interactive scan is plotted as a new series on top of the additive scan.
  - Both toggles can be active simultaneously, allowing for a three-way comparison (Additive, Diet Interactive, Sex Interactive).
- **Visualization**:
  - A legend is automatically displayed at the bottom of the plot to distinguish the scan types.
  - **Color Scheme**:
    - **Additive**: Blue (`#3498db`)
    - **Diet Interactive**: Dark Blue (`#2c3e50`)
    - **Sex Interactive**: Light Red (`#e74c3c`)
  - **Linewidths**: Interactive overlays are rendered with a slightly thicker line (`1.2`) than the base additive scan (`0.7`) to ensure they are clearly visible.
- **Implementation Pattern (`ggplot_qtl_scan`)**:
  - To handle multiple series reliably, the function combines the base `scan_table` and any active `overlay_data` into a single data frame.
  - A `type` column is added to this merged data frame to identify each series ("Additive", "Diet Interactive", "Sex Interactive").
  - `ggplot2` aesthetics (`color`, `linewidth`, `alpha`) are mapped to this `type` column.
  - `scale_*_manual` functions are used to assign specific visual properties to each scan type, ensuring a consistent and clear plot.

### Header Management

#### Avoid Duplicate Headers

- **Rule**: Never create static headers in sidebar for plots that have dynamic titles
- **Implementation**: Remove any `h5(textOutput("plot_title"))` or similar static headers
- **Dynamic Only**: Use only plot-level titles that change based on:
  - Dataset selection
  - Interaction type (additive vs sex/diet interactive)
  - Analysis mode (regular vs difference)

#### Header Cleanup Pattern

```r
# WRONG: Static sidebar header + dynamic plot title
h5(textOutput("plot_title")), # Remove this
plot_output_with_dynamic_title()

# CORRECT: Only dynamic plot titles
plot_output_with_dynamic_title() # Keep only this
```

## Package Structure

### Dependencies

- Core dependencies: shiny, bslib, dplyr, ggplot2, DT, data.table
- Visualization: plotly, ggiraph, shinycssloaders
- Data handling: fst, reshape2, stringr
- QTL-specific: qtl2
- Always specify minimum R version in DESCRIPTION (>= 4.2.0)

### File Sourcing Order

Source files in logical dependency order in `app.R`:

1. helpers.R (core utilities)
2. data_handling.R
3. import_data.R
4. Module files (\*Module.R)
5. Visualization functions
6. Analysis functions

### Package Development

- Use `devtools::document()` to build documentation
- Follow roxygen2 standards for all exported functions
- Update NAMESPACE automatically via roxygen2
- Use semantic versioning in DESCRIPTION

## Data Handling

### Caching Strategy

- Implement caching for expensive operations (peaks, traits)
- Use appropriate cache invalidation strategies
- Cache objects should be created via `create_cache()` function
- Use local module caches: `local_cache <- new.env(parent = emptyenv())`

### File Formats

- Prefer FST format for large datasets (fast read/write)
- Support CSV import for configuration files
- Use data.table for efficient data manipulation
- Implement `fst_rows()` for memory-efficient data access

### Chromosome Handling

- Use standardized chromosome conversion functions:
  - `chr_to_numeric()` for converting labels to numbers (X=20, Y=21, M=22)
  - `chr_XYM()` for display formatting
- Handle X, Y, M chromosomes consistently
- Maintain backward compatibility with existing functions

## Visualization Standards

### Plot Functions

- Separate ggplot2 and plotly implementations
- Use consistent color schemes and themes
- Implement responsive design for different screen sizes
- Add proper axis labels and titles
- Support both static and interactive plots

### Plot Organization

- `ggplot_*.R` for ggplot2 implementations
- `ggplotly_*.R` for plotly implementations
- `plot_enhancements.R` for styling and themes
- `plot_null.R` for fallback/empty state plots

### Interactive Plot Configuration

- Configure plotly plots for specific interaction patterns:
  - LOD scan plots: horizontal-only zoom (`yaxis: fixedrange = TRUE`)
  - Manhattan & Cis/Trans plots: Enable pinch-to-zoom and pan (`layout(dragmode = "pan") %>% config(scrollZoom = TRUE)`).
- Use `fixedrange = TRUE/FALSE` in plotly layout for axis-specific zoom control

### Strain Effects Plots

- Use horizontal layout with strains on x-axis for better readability
- Remove legends when strain names are displayed on axes
- Apply consistent strain color mapping across all visualizations
- Handle missing allele effects data gracefully with placeholder plots

### Cis-Trans Plots

- **Objective**: Display all-vs-all chromosome interactions in a single plot while preserving rich hover text and click-to-scan functionality.
- **Problem**: Using `ggplot2::facet_wrap()` by chromosome with `plotly::ggplotly()` can lead to inconsistent hover behavior and a cluttered appearance. `plotly::subplot()` can also be complex to manage for this type of plot.
- **Solution**: Implement a single-panel plot using cumulative genomic coordinates.
- **Colors**: For cis/trans distinction, use **blue for cis** and **red for trans**.

#### Implementation Pattern

1.  **Calculate Cumulative Positions**: Create a summary data frame of chromosome lengths. Use this to calculate a cumulative `BPcum` position for both QTLs (x-axis) and gene locations (y-axis). This maps the entire genome onto a continuous axis.

    ```r
    # Create chromosome summary for calculating cumulative positions
    chr_summary <- markers_data %>%
      dplyr::group_by(chr) %>%
      dplyr::summarise(chr_len = max(pos), .groups = 'drop') %>%
      dplyr::arrange(as.numeric(chr_to_numeric(chr))) %>%
      dplyr::mutate(
        tot = cumsum(as.numeric(chr_len)) - chr_len,
        center = tot + (chr_len / 2)
      )

    # Join with plot data to get cumulative positions for QTL and genes
    plot_df <- df_filtered %>%
      dplyr::left_join(chr_summary %>% dplyr::select(chr, tot), by = c("qtl_chr_char" = "chr")) %>%
      dplyr::mutate(qtl_BPcum = qtl_pos + tot) %>%
      # ... repeat for gene positions ...
    ```

2.  **Build with `ggplot2`**: Construct the plot using `ggplot2`, plotting the `qtl_BPcum` vs. `gene_BPcum`.

    - Use `geom_vline()` and `geom_hline()` with the cumulative chromosome boundaries to create the grid.
    - Use `scale_x_continuous()` and `scale_y_continuous()` with `breaks = chr_summary$center` and `labels = chr_summary$chr` to label the axes with chromosome names.
    - A `geom_abline()` shows the cis-diagonal.

3.  **Enhance with `plotly`**: Convert the final `ggplot` object to a `plotly` object using `plotly::ggplotly()`.

    - Pass a custom `text` aesthetic to `ggplot2::aes()` to control the hover text. This ensures that detailed, multi-line information is displayed correctly.

    ```r
    # Create hover text in a new column
    plot_data_dt[, hover_text := paste0(
      "Gene: ", gene_symbol, "<br>",
      "LOD: ", round(qtl_lod, 2), "<br>",
      "Gene Position: ", gene_chr_char, ":", round(gene_start, 2), " Mb<br>",
      "Marker Position: ", qtl_chr_char, ":", round(qtl_pos, 2), " Mb"
    )]

    # Build ggplot
    g <- ggplot2::ggplot(plot_data_dt, ggplot2::aes(..., text = hover_text)) + ...

    # Convert to plotly
    fig <- plotly::ggplotly(g, tooltip = "text")
    ```

- **Benefit**: This approach yields a clean, informative single plot that behaves predictably and performantly with `plotly`'s interactive features.

### LOD Plot Click Enhancement

- When clicking on LOD scan plot points, pull comprehensive peak information from peaks files
- Display cis/trans status, confidence intervals, and founder allele effects (A-H columns)
- Format click details in transposed Property-Value table for better readability
- Color-code cis/trans status (green for Cis, red for Trans)
- Include peak information in strain effects dropdown for easy peak selection

## User Experience Patterns

### Dataset Switching and State Management

- **Preserve Trait Selection**: Preserve trait selection when switching between compatible datasets (e.g., additive ↔ interactive).
- **Preserve Interaction State**: The selected interaction type (e.g., "sex", "diet") **must** be preserved when switching between dataset categories that support it. The view should only reset to "additive" if the new category does not support the active interaction type.
- **Prevent Auto-Search**: Use `dataset_just_changed` flags to prevent automatic expensive computations during dataset transitions.
- **Default to Additive**: When the main dataset category changes, both main and sidebar interaction analysis controls **must** be reset to "none" (additive) to ensure a clean state.
  ```r
  # Observer to reset interaction types to default when dataset category changes
  shiny::observeEvent(input$dataset_category_selector, {
      current_interaction_type_rv("none")
      sidebar_interaction_type_rv("none")
  }, ignoreInit = TRUE)
  ```

### LOD Scan View Controls

- **Dynamic Title**: The main plot card header should be dynamic, updating to show the currently scanned trait (e.g., "LOD Scan for Trait: [Trait Name]").
- **Consolidated Controls**: Interaction Analysis and Chromosome selectors should be located inside the main plot area, only appearing when a trait is selected for scanning.
- **Control Layout**: The "Interaction Analysis" dropdown should be on the left, and the "Chromosome" selector on the right.
- **No Redundant Buttons**: Remove any extra "Zoom" buttons. The chromosome selection dropdown is sufficient. Use a "Reset Zoom" button to return to the "All" chromosome view.
- **No Redundant Headers**: Remove static text headers like "Click on plot to see point details:". The plot and its data table should be self-explanatory.

### Trait Search Workflow

- **Server-Side Selectize**: Implement server-side selectize for large trait lists (`server = TRUE`) to ensure performance.
- **Support both manual search button and auto-search functionality**
- **Use intelligent auto-search prevention during dataset changes**
- **Clear and informative placeholder text and notifications**

### Dynamic LOD Thresholds

- Set different default thresholds based on scan type:
  - Additive scans: 7.5
  - Interactive scans: 10.5
- Use debounced reactive for LOD threshold to prevent double firing
- Update slider UI dynamically when scan type changes

## Error Handling and Performance

### Reactive Performance Optimization

```r
# Debouncing patterns for different operations
scan_data <- reactive({ ... }) %>% debounce(150)      # Data loading
plot_creation <- reactive({ ... }) %>% debounce(200)   # Plot generation
difference_plot <- reactive({ ... }) %>% debounce(250) # Difference calculations
lod_threshold <- reactive({ ... }) %>% debounce(300)   # LOD threshold changes
```

### Error Prevention

- Always check data compatibility before operations
- Handle NA values explicitly in calculations
- Provide meaningful error messages to users
- Use `tryCatch()` for external data operations
- Implement graceful fallbacks for missing data
- **Avoid `overflow: hidden;` in CSS for containers with Plotly plots**, as it can interfere with zoom/pan event handling and cause mouseover lag.

### Memory Management

- Clear caches when datasets change
- Use local environments for module-specific caches
- Avoid storing large objects in global reactive values
- Use `rm()` to explicitly clear cache environments

## Git and Development

### Commit Standards

- Use descriptive commit messages
- Commit logical units of work
- Test functionality before committing
- Update documentation when adding new features

### Collaboration

- Work on modular components to enable parallel development
- Use GitHub for version control and collaboration
- Follow the modular design to minimize merge conflicts
- Document new modules and functions thoroughly

### Development Environment

- If file changes are not being reflected in the running application, it is likely due to Docker's layer caching. Rebuild the Docker image using the `--no-cache` flag to force a clean build.
  ```bash
  # Example command
  docker build --no-cache -t your-image-name .
  ```

## Testing and Quality

### Code Quality

- Functions should be focused and do one thing well
- Avoid functions longer than 100 lines
- Use meaningful variable names
- Add comments for complex logic
- Validate inputs and handle edge cases

### Performance

- Use efficient data structures (data.table for large data)
- Implement caching for expensive operations
- Use FST format for fast I/O
- Optimize Shiny reactivity patterns with debouncing
- Monitor and prevent unnecessary trait scans during UI updates

## Specific Project Conventions

### Trait Handling

- Support multiple trait types: genes, isoforms, clinical, lipids
- Use standardized trait ID mapping via `get_trait_id()`
- Implement robust trait choice generation with `get_trait_choices()`
- Handle missing or invalid trait data gracefully
- Preserve trait selections across compatible dataset changes

### Peak Analysis

- Use consistent LOD threshold filtering
- Support allele effect visualization (A-H columns → strain names)
- Implement peak reshaping for visualization via `pivot_peaks()`
- Handle missing markers and invalid peak data
- Extract and display comprehensive peak metadata:
  - `cis` column (TRUE/FALSE) for cis vs trans QTL classification
  - `qtl_ci_lo` and `qtl_ci_hi` for confidence intervals
  - A, B, C, D, E, F, G, H founder allele effects
  - Standard QTL information (chromosome, position, LOD score)

### Data Import

- Support flexible dataset configuration via CSV files
- Validate file directory structure and trait types
- Implement robust annotation list handling
- Provide clear error messages for import failures

### Data Processing Pipeline

- Use `kalynn_R/latest_app_kalynn/chromosome_compile.R` to compile raw gz files
- Use `kalynn_R/latest_app_kalynn/prepare_fst_data.R` to process and sort FST files
- All processed files are automatically sorted by Phenotype for efficient access
- Row indices are generated automatically for fast trait-based reading
- See `kalynn_R/latest_app_kalynn/.cursorrules` for detailed processing guidelines

### App Architecture Patterns

- Implement modular components for extensibility (`scanApp_optimized.R`)
- Add placeholder sections for future functionality (Profile Plot, Correlation)
- Use consistent namespace patterns across modules

## Notification Standards

- Use appropriate Shiny notification types: "message", "warning", "error", "default"
- Provide informative duration settings for different message types
- Include actionable guidance in notification text
- Use consistent notification patterns across the application

## Peak Information Display Standards

- Use transposed Property-Value tables for detailed peak click information
- Color-code biological classifications (cis=green, trans=red)
- Include comprehensive metadata in peak selection dropdowns
- Format confidence intervals and coordinates consistently
- Display founder allele effects with clear strain labeling

### Founder Allele Effects Display

**Enhanced Display Format**: Show actual founder allele effect values instead of just listing available columns.

**Implementation Pattern**:

```r
# Map A-H columns to strain names
allele_cols <- c("A", "B", "C", "D", "E", "F", "G", "H")
strain_names <- c("AJ", "B6", "129", "NOD", "NZO", "CAST", "PWK", "WSB")
available_alleles <- allele_cols[allele_cols %in% colnames(peak_info)]

# Extract actual values
allele_effects <- list()
for (i in seq_along(available_alleles)) {
  col <- available_alleles[i]
  value <- peak_info[[col]]
  if (!is.na(value) && !is.null(value)) {
    strain <- strain_names[i]
    allele_effects[[length(allele_effects) + 1]] <- paste0(strain, ": ", round(value, 3))
  }
}

# Display in monospace format
tags$div(
  style = "margin-left: 10px; font-family: monospace; font-size: 11px;",
  lapply(allele_effects, function(effect) {
    tags$div(effect, style = "margin: 2px 0;")
  })
)
```

**Display Format**:

- **Before**: "Founder Effects: 8 available (A, B, C, D, E, F, G, H)"
- **After**:
  ```
  Founder Effects:
    AJ: -0.136
    B6: 0.078
    129: 0.182
    NOD: 0.114
    NZO: 0.017
    CAST: -0.073
    PWK: -0.109
    WSB: -0.074
  ```

**Key Requirements**:

- Use strain names (AJ, B6, 129, NOD, NZO, CAST, PWK, WSB) instead of A-H columns
- Round values to 3 decimal places for readability
- Use monospace font for proper alignment
- Fallback to old format if no valid effects are found
- Handle both modular (`alleleEffectsModule.R`) and monolithic versions

## File Naming Conventions

- `*Module.R` for Shiny modules
- `*_functions.R` or descriptive names for utility functions
- `ggplot_*.R` for ggplot2 visualization functions
- `data_*.R` for data handling functions
- Use lowercase with underscores for file names

## Interactive Analysis Implementation Details

### Dataset Mapping Logic

**Supported Interactive Datasets:**

- **HC_HF Liver Genes**: Supports both Sex and Diet interactions
  - Sex: `"HC_HF Liver Genes, interactive (Sex)"`
  - Diet: `"HC_HF Liver Genes, interactive (Diet)"`
- **HC_HF Liver Lipids**: Supports Diet interaction only
  - Diet: `"HC_HF Liver Lipids, interactive (Diet)"`
- **HC_HF Clinical Traits**: Supports both Sex and Diet interactions
  - Sex: `"HC_HF Systemic Clinical Traits, interactive (Sex)"`
  - Diet: `"HC_HF Systemic Clinical Traits, interactive (Diet)"`
- **HC_HF Plasma Metabolites**: Supports Sex interaction only
  - Sex: `"HC_HF Plasma Metabolites, interactive (Sex)"`
- **HC_HF Liver Isoforms**: No interactive analysis available

### On-the-Fly Difference Plot Data Flow (LOD Scan)

1.  **Automatic Additive Loading**: When an interactive analysis is selected (e.g., "sex" or "diet"), the corresponding additive dataset scan **must** be loaded automatically in the background. The user should not be required to manually select the additive ("none") version first.
2.  **Robust Caching**: The loaded additive scan data for a given trait should be cached in a reactive value (`reactiveVal`). This cache must be cleared when the selected trait changes, but **not** when the interaction type changes (e.g., switching from "sex" to "diet"). This prevents slow, redundant data loading.
3.  **Derive Additive Dataset Name**: The additive dataset name is derived by removing the interactive part from the name and appending ", additive".
    ```r
    # Correct logic for deriving additive dataset name
    base_name <- gsub(",\\s*interactive\\s*\\([^)]+\\)", "", interactive_dataset_name)
    additive_dataset_name <- paste0(trimws(base_name), ", additive")
    ```
4.  **Load Additive Data**: In the background, load the scan data for the derived additive dataset name (`additive_dataset_name`). This data should be stored in a reactive value (e.g., `additive_scan_data_rv`).
5.  **Prevent Incorrect Caching**: When storing additive scan data from a "none" interaction type, ensure the source data is genuinely from an additive dataset, not an interactive one that happens to have its interaction type set to "none".
    ```r
    # GOOD: Guard against incorrect caching
    if (!grepl("interactive", current_dataset_name, ignore.case = TRUE)) {
      additive_scan_data_rv(plot_data)
    }
    ```
6.  **Calculate Difference**: Subtract the stored additive LOD scores from the interactive LOD scores.
7.  **Handle Missing Data**: Use `is.null()` and `nrow()` checks before calculations.
8.  **Create Plot**: Pass the difference data to `ggplot_qtl_scan()` with `-Inf` threshold.

### QTLxCovar File Handling

#### File Path Mapping Functions

```r
# For Cis-Trans plots
get_qtlxcovar_file_path <- function(base_dataset, interaction_type) {
  qtlxcovar_dir <- "/data/dev/miniViewer_3.0"

  # Map dataset categories to file prefixes
  if (grepl("Liver.*Genes", base_dataset, ignore.case = TRUE)) {
    file_prefix <- "DO1200_liver_genes_all_mice"
  } else if (grepl("Clinical", base_dataset, ignore.case = TRUE)) {
    file_prefix <- "DO1200_clinical_traits_all_mice"
  } else {
    return(NULL)
  }

  # Map interaction type to file suffix
  file_suffix <- if (interaction_type == "sex") "qtlxsex_peaks.csv" else "qtlxdiet_peaks.csv"

  return(file.path(qtlxcovar_dir, paste0(file_prefix, "_", file_suffix)))
}

# For Manhattan plots (similar but supports more dataset types)
get_qtlxcovar_file_path_manhattan <- function(base_dataset, interaction_type) {
  qtlxcovar_dir <- "/data/dev/miniViewer_3.0"

  if (grepl("Clinical", base_dataset, ignore.case = TRUE)) {
    file_prefix <- "DO1200_clinical_traits_all_mice"
  } else if (grepl("Liver.*Lipid", base_dataset, ignore.case = TRUE)) {
    file_prefix <- "DO1200_liver_lipids_all_mice"
  } else if (grepl("Plasma.*Metabol", base_dataset, ignore.case = TRUE)) {
    file_prefix <- "DO1200_plasma_metabolites_all_mice"
  } else {
    return(NULL)
  }

  file_suffix <- if (interaction_type == "sex") "qtlxsex_peaks.csv" else "qtlxdiet_peaks.csv"
  return(file.path(qtlxcovar_dir, paste0(file_prefix, "_", file_suffix)))
}
```

#### Data Loading Pattern

```r
# Check if we should use qtlxcovar data
use_qtlxcovar <- !is.null(interaction_type) && interaction_type != "none" &&
  !is.null(base_dataset) && grepl("^HC_HF", base_dataset, ignore.case = TRUE)

if (use_qtlxcovar) {
  qtlxcovar_file <- get_qtlxcovar_file_path(base_dataset, interaction_type)
  if (!is.null(qtlxcovar_file) && file.exists(qtlxcovar_file)) {
    found_peaks <- data.table::fread(qtlxcovar_file)
  }
} else {
  # Use regular peak_finder for additive analysis
  found_peaks <- peak_finder(...)
}
```

```r
# Determine interactive dataset name
get_interactive_dataset_name <- function(base_dataset, interaction_type) {
  if (interaction_type == "sex") {
    return("HC_HF Liver Genes, interactive (Sex)")  # Also supports HC_HF Plasma Metabolites
  } else if (interaction_type == "diet") {
    return("HC_HF Liver Genes, interactive (Diet)")  # Also supports other HC_HF datasets
  }
  return(base_dataset)  # fallback to additive
}
```

### Difference Plot Data Flow

- **Store Additive**: When interaction_type == "none", store scan data.
- **Calculate Difference**: When interaction_type != "none", subtract stored additive from current interactive.
- **Handle Missing Data**: Use `is.null()` and `nrow()` checks before calculations.
- **Element-wise Operation**: Simple `interactive$LOD - additive$LOD` with NA handling.
- **Create Plot**: Pass difference data to `ggplot_qtl_scan()` with `-Inf` threshold.

### UI State Management

- Use `show_stacked_plots()` reactive to determine single vs stacked layout.
- Implement proper height division for stacked plots.
- Add descriptive titles for each plot section.
- Use color-coded spinners to distinguish plot types.

This modular architecture enables:

- **Better Performance**: Debounced reactives prevent excessive computations
- **Maintainability**: Small, focused modules are easier to understand and modify
- **Extensibility**: New features can be added as separate modules
- **Reusability**: Modules can be reused across different parts of the application
- **Testing**: Individual modules can be tested in isolation
