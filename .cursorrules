# qtlApp Cursor Rules

## Project Overview

This is an R package for QTL (Quantitative Trait Loci) analysis and visualization using Shiny. The project is organized as a modular package with multiple small Shiny modules for scalable QTL analysis with support for interactive sex/diet difference plots.

## R Language Standards

### Code Style

- Use 2-space indentation consistently throughout all R files
- Use `|>` (native pipe) instead of `%>%` (magrittr pipe) for new code
- Be explicit about package namespacing: use `package::function()` format
- Use snake_case for function names and variables
- Use descriptive variable names that clearly indicate their purpose

### Function Documentation

- All exported functions must have roxygen2 documentation with `@export`
- Include `@param` for all parameters with clear descriptions
- Include `@return` to describe what the function returns
- Add `@importFrom` for specific package functions used
- Example format:

```r
#' Function description
#' @param param_name Description of parameter
#' @return Description of return value
#' @importFrom package function
#' @export
```

### Error Handling

- Use `shiny::req()` for required inputs in Shiny contexts
- Implement comprehensive error checking with informative warning messages
- Check for NULL values, empty data frames, and missing columns before processing
- Return appropriate default values (e.g., `character(0)`, `NULL`) when data is invalid
- Use `warning()` for non-fatal issues with descriptive messages

### Data Validation

- Always validate data frame structure before processing
- Check for required columns using `%in% colnames()`
- Validate data types and handle type conversions safely
- Filter out NA values and empty strings where appropriate
- Use `is.null()`, `is.data.frame()`, `nrow() == 0` checks

## Shiny Application Structure

### Modular Design

- Break functionality into small, focused Shiny modules (~50-100 lines each)
- Each module should handle a specific task (scanning, peaks, traits, interactive analysis, etc.)
- Use consistent naming: `*Module.R` for module files
- Modules should be interconnectable like "legos"

### File Organization

- Main app logic in `app.R`
- Helper functions in `R/helpers.R`
- Data handling functions in `R/data_handling.R`
- Each major feature gets its own module file in `R/`
- UI styling in `R/ui_styles.R`
- Plot functions separated by type (ggplot, plotly, etc.)

### Modular Architecture Patterns

#### Core Modules

- `scanPlotModule.R` - LOD scan visualization with interactive/difference plots
- `alleleEffectsModule.R` - Strain effects visualization and peak selection
- `interactiveAnalysisModule.R` - Sex/diet interaction controls
- `datasetSelectionModule.R` - Dataset category and specific dataset selection

#### Module Communication

- Use reactive values and functions for inter-module communication
- Pass reactive parameters explicitly to maintain clear dependencies
- Return reactive values from modules for external access
- Use debouncing (`shiny::debounce()`) on expensive reactive operations

#### Module Patterns

```r
#' Module Server Pattern
moduleServer <- function(id, param1_reactive, param2_reactive, ...) {
  shiny::moduleServer(id, function(input, output, session) {
    ns <- session$ns

    # Local reactive values
    local_rv <- shiny::reactiveVal(NULL)

    # Debounced reactives for performance
    expensive_computation <- shiny::reactive({
      # computation logic
    }) %>% shiny::debounce(200)

    # Return reactive interface
    return(list(
      output_reactive = local_rv,
      computed_data = expensive_computation
    ))
  })
}
```

### Shiny Best Practices

- Use `bslib` for modern Bootstrap styling
- Implement loading indicators with `shinycssloaders`
- Use `shinyjs` for enhanced interactivity
- Set appropriate file upload limits: `options(shiny.maxRequestSize = 20000*1024^2)`
- Use reactive expressions efficiently to avoid unnecessary computations

### Performance Optimization

#### Reactive Debouncing

- Use `shiny::debounce()` on expensive reactive operations
- Debounce ranges: 100-150ms for data processing, 200-300ms for plot creation, 200-250ms for difference plots
- Example: `reactive_function %>% shiny::debounce(200)`

#### Reactive Dependency Management

- Avoid circular reactive dependencies
- Use `shiny::isolate()` when needed to break reactive chains
- Use `shiny::req()` to prevent premature reactive execution
- Clear reactive flags and use timed resets for UI state management

#### Preventing Double Firing in UI Reactive Chains

**Problem**: UI components that depend on reactive values which in turn depend on UI inputs can create circular reactive dependencies, causing UI to fire multiple times.

**Solution Pattern**: Separate base reactives from mapped/derived reactives to break circular dependencies.

```r
# WRONG: Circular dependency causes double firing
main_reactive <- shiny::reactive({
  base_value <- input$base_selector
  ui_dependent_value <- input$ui_selector  # UI depends on this reactive!
  # Process both values together
  process_values(base_value, ui_dependent_value)
})

# UI that depends on main_reactive creates circular dependency
output$ui_section <- shiny::renderUI({
  result <- main_reactive()  # This can trigger when input$ui_selector changes
  # Render UI that includes input$ui_selector
})

# CORRECT: Separate base and mapped reactives
base_reactive <- shiny::reactive({
  base_value <- input$base_selector
  # NO dependency on UI-dependent inputs
  return(base_value)
})

mapped_reactive <- shiny::reactive({
  base_value <- base_reactive()
  ui_value <- input$ui_selector
  # Only this reactive depends on UI input
  process_values(base_value, ui_value)
})

# UI depends only on base reactive (no circular dependency)
output$ui_section <- shiny::renderUI({
  base_value <- base_reactive()  # Independent of input$ui_selector
  # Render UI safely
})

# Data processing uses mapped reactive
process_data <- function() {
  mapped_value <- mapped_reactive()  # Gets the mapped result
  # Use mapped value for actual processing
}
```

**Key Principles**:

- Base reactives should be independent of UI elements they influence
- Create separate mapping reactives for conditional logic
- UI renderUI functions should depend only on stable base reactives
- Use mapped reactives for data processing that needs conditional values

#### Trait Preservation and Auto-Search

- Preserve trait selection when switching between compatible datasets (e.g., additive ↔ interactive)
- Use `dataset_just_changed` flags to prevent auto-search during dataset transitions
- Implement intelligent auto-search with user control (search button + auto-trigger)
- Use server-side selectize for large trait lists with `server = TRUE`

## Interactive Analysis and Difference Plots

### Sex/Diet Interaction Support

- Support interactive analysis for specific datasets (HC_HF Liver Genes)
- Automatically map interaction types to correct dataset names:
  - "none" → base dataset (additive)
  - "sex" → "HC_HF Liver Genes, interactive (Sex)"
  - "diet" → "HC_HF Liver Genes, interactive (Diet)"

### Difference Plot Implementation

- **Simple Element-wise Subtraction**: `interactive_LOD[i] - additive_LOD[i]`
- **Data Compatibility**: Ensure both datasets have same number of rows and markers
- **NA Handling**: Replace NA values with 0 for visualization
- **Stacked Layout**: Show interactive plot on top, difference plot on bottom
- **Height Management**: Split total height between two plots (`height / 2`)

### Difference Plot Architecture

```r
# Store additive data when interaction type is "none"
additive_scan_data_rv <- shiny::reactiveVal(NULL)

# Create difference plot
difference_plot_gg <- shiny::reactive({
  interactive_data <- scan_table_chr()
  additive_data <- additive_scan_data_rv()

  # Simple subtraction with NA handling
  lod_difference <- interactive_data$LOD - additive_data$LOD
  lod_difference[is.na(lod_difference)] <- 0

  # Create plot data
  diff_plot_data <- interactive_data
  diff_plot_data$LOD <- lod_difference

  ggplot_qtl_scan(diff_plot_data, -Inf, selected_chr)
}) %>% shiny::debounce(250)
```

### UI Stacking for Interactive Analysis

- **Single Plot**: Standard LOD scan for additive datasets
- **Stacked Plots**: Interactive LOD (top) + Difference LOD (bottom) for interactive datasets
- **Plot Titles**: "Interactive LOD Scan" and "LOD Difference (Interactive - Additive)"
- **Color Coding**: Blue spinners for main plots, red spinners for difference plots

## Package Structure

### Dependencies

- Core dependencies: shiny, bslib, dplyr, ggplot2, DT, data.table
- Visualization: plotly, ggiraph, shinycssloaders
- Data handling: fst, reshape2, stringr
- QTL-specific: qtl2
- Always specify minimum R version in DESCRIPTION (>= 4.2.0)

### File Sourcing Order

Source files in logical dependency order in `app.R`:

1. helpers.R (core utilities)
2. data_handling.R
3. import_data.R
4. Module files (\*Module.R)
5. Visualization functions
6. Analysis functions

### Package Development

- Use `devtools::document()` to build documentation
- Follow roxygen2 standards for all exported functions
- Update NAMESPACE automatically via roxygen2
- Use semantic versioning in DESCRIPTION

## Data Handling

### Caching Strategy

- Implement caching for expensive operations (peaks, traits)
- Use appropriate cache invalidation strategies
- Cache objects should be created via `create_cache()` function
- Use local module caches: `local_cache <- new.env(parent = emptyenv())`

### File Formats

- Prefer FST format for large datasets (fast read/write)
- Support CSV import for configuration files
- Use data.table for efficient data manipulation
- Implement `fst_rows()` for memory-efficient data access

### Chromosome Handling

- Use standardized chromosome conversion functions:
  - `chr_to_numeric()` for converting labels to numbers (X=20, Y=21, M=22)
  - `chr_XYM()` for display formatting
- Handle X, Y, M chromosomes consistently
- Maintain backward compatibility with existing functions

## Visualization Standards

### Plot Functions

- Separate ggplot2 and plotly implementations
- Use consistent color schemes and themes
- Implement responsive design for different screen sizes
- Add proper axis labels and titles
- Support both static and interactive plots

### Plot Organization

- `ggplot_*.R` for ggplot2 implementations
- `ggplotly_*.R` for plotly implementations
- `plot_enhancements.R` for styling and themes
- `plot_null.R` for fallback/empty state plots

### Interactive Plot Configuration

- Configure plotly plots for specific interaction patterns:
  - LOD scan plots: horizontal-only zoom (`yaxis: fixedrange = TRUE`)
  - Manhattan plots: pan-only interaction (`dragmode = "pan"`)
  - Strain effects: no legend needed when strains are on axes (`guide = "none"`)
- Use `fixedrange = TRUE/FALSE` in plotly layout for axis-specific zoom control

### Strain Effects Plots

- Use horizontal layout with strains on x-axis for better readability
- Remove legends when strain names are displayed on axes
- Apply consistent strain color mapping across all visualizations
- Handle missing allele effects data gracefully with placeholder plots

### LOD Plot Click Enhancement

- When clicking on LOD scan plot points, pull comprehensive peak information from peaks files
- Display cis/trans status, confidence intervals, and founder allele effects (A-H columns)
- Format click details in transposed Property-Value table for better readability
- Color-code cis/trans status (green for Cis, red for Trans)
- Include peak information in strain effects dropdown for easy peak selection

## User Experience Patterns

### Dataset Switching

- Preserve trait selection when switching between datasets in the same category
- Prevent automatic expensive computations during dataset transitions
- Use `reactiveVal` flags with timed resets to control auto-search behavior
- Provide clear notifications about preserved selections and required actions

### Trait Search Workflow

- Implement server-side selectize for large trait lists (`server = TRUE`)
- Support both manual search button and auto-search functionality
- Use intelligent auto-search prevention during dataset changes
- Clear and informative placeholder text and notifications

### Dynamic LOD Thresholds

- Set different default thresholds based on scan type:
  - Additive scans: 7.5
  - Interactive scans: 10.5
- Use debounced reactive for LOD threshold to prevent double firing
- Update slider UI dynamically when scan type changes

## Error Handling and Performance

### Reactive Performance Optimization

```r
# Debouncing patterns for different operations
scan_data <- reactive({ ... }) %>% debounce(150)      # Data loading
plot_creation <- reactive({ ... }) %>% debounce(200)   # Plot generation
difference_plot <- reactive({ ... }) %>% debounce(250) # Difference calculations
lod_threshold <- reactive({ ... }) %>% debounce(300)   # LOD threshold changes
```

### Error Prevention

- Always check data compatibility before operations
- Handle NA values explicitly in calculations
- Provide meaningful error messages to users
- Use `tryCatch()` for external data operations
- Implement graceful fallbacks for missing data

### Memory Management

- Clear caches when datasets change
- Use local environments for module-specific caches
- Avoid storing large objects in global reactive values
- Use `rm()` to explicitly clear cache environments

## Git and Development

### Commit Standards

- Use descriptive commit messages
- Commit logical units of work
- Test functionality before committing
- Update documentation when adding new features

### Collaboration

- Work on modular components to enable parallel development
- Use GitHub for version control and collaboration
- Follow the modular design to minimize merge conflicts
- Document new modules and functions thoroughly

## Testing and Quality

### Code Quality

- Functions should be focused and do one thing well
- Avoid functions longer than 100 lines
- Use meaningful variable names
- Add comments for complex logic
- Validate inputs and handle edge cases

### Performance

- Use efficient data structures (data.table for large data)
- Implement caching for expensive operations
- Use FST format for fast I/O
- Optimize Shiny reactivity patterns with debouncing
- Monitor and prevent unnecessary trait scans during UI updates

## Specific Project Conventions

### Trait Handling

- Support multiple trait types: genes, isoforms, clinical, lipids
- Use standardized trait ID mapping via `get_trait_id()`
- Implement robust trait choice generation with `get_trait_choices()`
- Handle missing or invalid trait data gracefully
- Preserve trait selections across compatible dataset changes

### Peak Analysis

- Use consistent LOD threshold filtering
- Support allele effect visualization (A-H columns → strain names)
- Implement peak reshaping for visualization via `pivot_peaks()`
- Handle missing markers and invalid peak data
- Extract and display comprehensive peak metadata:
  - `cis` column (TRUE/FALSE) for cis vs trans QTL classification
  - `qtl_ci_lo` and `qtl_ci_hi` for confidence intervals
  - A, B, C, D, E, F, G, H founder allele effects
  - Standard QTL information (chromosome, position, LOD score)

### Data Import

- Support flexible dataset configuration via CSV files
- Validate file directory structure and trait types
- Implement robust annotation list handling
- Provide clear error messages for import failures

### Data Processing Pipeline

- Use `kalynn_R/latest_app_kalynn/chromosome_compile.R` to compile raw gz files
- Use `kalynn_R/latest_app_kalynn/prepare_fst_data.R` to process and sort FST files
- All processed files are automatically sorted by Phenotype for efficient access
- Row indices are generated automatically for fast trait-based reading
- See `kalynn_R/latest_app_kalynn/.cursorrules` for detailed processing guidelines

### App Architecture Patterns

- Use monolithic backup file (`scanApp_monolithic_backup.R`) for stable features
- Implement modular components for extensibility (`scanApp_optimized.R`)
- Add placeholder sections for future functionality (Profile Plot, Correlation)
- Use consistent namespace patterns across modules

## Notification Standards

- Use appropriate Shiny notification types: "message", "warning", "error", "default"
- Provide informative duration settings for different message types
- Include actionable guidance in notification text
- Use consistent notification patterns across the application

## Peak Information Display Standards

- Use transposed Property-Value tables for detailed peak click information
- Color-code biological classifications (cis=green, trans=red)
- Include comprehensive metadata in peak selection dropdowns
- Format confidence intervals and coordinates consistently
- Display founder allele effects with clear strain labeling

## File Naming Conventions

- `*Module.R` for Shiny modules
- `*_functions.R` or descriptive names for utility functions
- `ggplot_*.R` for ggplot2 visualization functions
- `data_*.R` for data handling functions
- Use lowercase with underscores for file names

## Interactive Analysis Implementation Details

### Dataset Mapping Logic

```r
# Determine interactive dataset name
get_interactive_dataset_name <- function(base_dataset, interaction_type) {
  if (interaction_type == "sex") {
    return("HC_HF Liver Genes, interactive (Sex)")
  } else if (interaction_type == "diet") {
    return("HC_HF Liver Genes, interactive (Diet)")
  }
  return(base_dataset)  # fallback to additive
}
```

### Difference Plot Data Flow

1. **Store Additive**: When interaction_type == "none", store scan data
2. **Calculate Difference**: When interaction_type != "none", subtract stored additive from current interactive
3. **Handle Missing Data**: Use `is.null()` and `nrow()` checks before calculations
4. **Element-wise Operation**: Simple `interactive$LOD - additive$LOD` with NA handling
5. **Create Plot**: Pass difference data to `ggplot_qtl_scan()` with `-Inf` threshold

### UI State Management

- Use `show_stacked_plots()` reactive to determine single vs stacked layout
- Implement proper height division for stacked plots
- Add descriptive titles for each plot section
- Use color-coded spinners to distinguish plot types

This modular architecture enables:

- **Better Performance**: Debounced reactives prevent excessive computations
- **Maintainability**: Small, focused modules are easier to understand and modify
- **Extensibility**: New features can be added as separate modules
- **Reusability**: Modules can be reused across different parts of the application
- **Testing**: Individual modules can be tested in isolation
